/* automatically generated by rust-bindgen 0.59.1 */

#![allow(non_camel_case_types)]
pub(crate) const ARCHIVE_EOF: i32 = 1;
pub(crate) const ARCHIVE_OK: i32 = 0;

pub(crate) const ARCHIVE_EXTRACT_OWNER: u32 = 1;
pub(crate) const ARCHIVE_EXTRACT_PERM: u32 = 2;
pub(crate) const ARCHIVE_EXTRACT_TIME: u32 = 4;
pub(crate) const ARCHIVE_EXTRACT_ACL: u32 = 32;
pub(crate) const ARCHIVE_EXTRACT_FFLAGS: u32 = 64;
pub(crate) const ARCHIVE_EXTRACT_XATTR: u32 = 128;
pub(crate) type __int64_t = ::std::os::raw::c_long;
pub(crate) type __dev_t = ::std::os::raw::c_ulong;
pub(crate) type __uid_t = ::std::os::raw::c_uint;
pub(crate) type __gid_t = ::std::os::raw::c_uint;
pub(crate) type __ino_t = ::std::os::raw::c_ulong;
pub(crate) type __mode_t = ::std::os::raw::c_uint;
pub(crate) type __nlink_t = ::std::os::raw::c_ulong;
pub(crate) type __off_t = ::std::os::raw::c_long;
pub(crate) type __time_t = ::std::os::raw::c_long;
pub(crate) type __blksize_t = ::std::os::raw::c_long;
pub(crate) type __blkcnt_t = ::std::os::raw::c_long;
pub(crate) type __ssize_t = ::std::os::raw::c_long;
pub(crate) type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct timespec {
    pub(crate) tv_sec: __time_t,
    pub(crate) tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct stat {
    pub(crate) st_dev: __dev_t,
    pub(crate) st_ino: __ino_t,
    pub(crate) st_nlink: __nlink_t,
    pub(crate) st_mode: __mode_t,
    pub(crate) st_uid: __uid_t,
    pub(crate) st_gid: __gid_t,
    pub(crate) __pad0: ::std::os::raw::c_int,
    pub(crate) st_rdev: __dev_t,
    pub(crate) st_size: __off_t,
    pub(crate) st_blksize: __blksize_t,
    pub(crate) st_blocks: __blkcnt_t,
    pub(crate) st_atim: timespec,
    pub(crate) st_mtim: timespec,
    pub(crate) st_ctim: timespec,
    pub(crate) __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
pub(crate) type la_int64_t = i64;
pub(crate) type la_ssize_t = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct archive {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct archive_entry {
    _unused: [u8; 0],
}
pub(crate) type archive_read_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut archive,
        _client_data: *mut ::std::os::raw::c_void,
        _buffer: *mut *const ::std::os::raw::c_void,
    ) -> la_ssize_t,
>;
pub(crate) type archive_seek_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut archive,
        _client_data: *mut ::std::os::raw::c_void,
        offset: la_int64_t,
        whence: ::std::os::raw::c_int,
    ) -> la_int64_t,
>;
pub(crate) type archive_open_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut archive,
        _client_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub(crate) type archive_close_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut archive,
        _client_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub(crate) fn archive_read_new() -> *mut archive;
}
extern "C" {
    pub(crate) fn archive_read_support_filter_all(arg1: *mut archive) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_read_support_format_all(arg1: *mut archive) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_read_support_format_raw(arg1: *mut archive) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_read_set_seek_callback(
        arg1: *mut archive,
        arg2: archive_seek_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_read_open(
        arg1: *mut archive,
        _client_data: *mut ::std::os::raw::c_void,
        arg2: archive_open_callback,
        arg3: archive_read_callback,
        arg4: archive_close_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_read_next_header(
        arg1: *mut archive,
        arg2: *mut *mut archive_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_read_data_block(
        a: *mut archive,
        buff: *mut *const ::std::os::raw::c_void,
        size: *mut usize,
        offset: *mut la_int64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_read_close(arg1: *mut archive) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_read_free(arg1: *mut archive) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_write_header(
        arg1: *mut archive,
        arg2: *mut archive_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_write_data_block(
        arg1: *mut archive,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: la_int64_t,
    ) -> la_ssize_t;
}
extern "C" {
    pub(crate) fn archive_write_finish_entry(arg1: *mut archive) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_write_close(arg1: *mut archive) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_write_free(arg1: *mut archive) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_write_disk_new() -> *mut archive;
}
extern "C" {
    pub(crate) fn archive_write_disk_set_options(
        arg1: *mut archive,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_write_disk_set_standard_lookup(
        arg1: *mut archive,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_errno(arg1: *mut archive) -> ::std::os::raw::c_int;
}
extern "C" {
    pub(crate) fn archive_error_string(arg1: *mut archive) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub(crate) fn archive_set_error(
        arg1: *mut archive,
        _err: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub(crate) fn archive_entry_free(arg1: *mut archive_entry);
}
extern "C" {
    pub(crate) fn archive_entry_hardlink(arg1: *mut archive_entry)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub(crate) fn archive_entry_pathname(arg1: *mut archive_entry)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub(crate) fn archive_entry_set_hardlink(
        arg1: *mut archive_entry,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub(crate) fn archive_entry_set_pathname(
        arg1: *mut archive_entry,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub(crate) fn archive_entry_stat(arg1: *mut archive_entry) -> *const stat;
}
